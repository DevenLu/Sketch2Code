// (ctrl shift p)

if([selection count] == 0)
{
   log("No selection found")
   return
}

var target = selection[0]

if (![target isKindOfClass:[MSLayerGroup class]])
{
   log("Not a group")
   return
}

log("Target:" + target)

var baseDir = get_dir_from_prompt()
var webView = [WebView new]

log("baseDir:" + baseDir)

//Currently only that is supported
var classMapping = loadObjectMap()
var viewDescriptors = loadSnippet("Common")
var targetTemplates = loadSnippet("UITableViewCell")

log("Assembling snippet")

var interfaceContent = mockInterface(targetTemplates["UITableViewCell"])
var implementationContent = mockImplementation(targetTemplates["UITableViewCell"])

log("Replacing template tags")

var templateParts = templateBinding(target);

interfaceContent = templateCodeWithDictionary(interfaceContent, templateParts)
implementationContent = templateCodeWithDictionary(implementationContent, templateParts)

log("Writing files")

writeTextToFile(baseDir + "/" + [target name] + ".h", interfaceContent)
writeTextToFile(baseDir + "/" + [target name] + ".m", implementationContent)

log("Writing files [Done]")

///////////////FUNCTIONS///////////////

function mockInterface(snippet)
{
    var headerSnippetPart = snippet[@"header"]

    return renderItems([NSArray arrayWithObjects:headerSnippetPart[@"imports"],
                       headerSnippetPart[@"interface_tag"]])
}

function mockImplementation(snippet)
{
    var implementationSnippetPart = snippet[@"implementation"]

    return renderItems([NSArray arrayWithObjects:implementationSnippetPart[@"imports"],
                       implementationSnippetPart[@"implementation_tag"][0],
                       implementationSnippetPart[@"create"],
                       implementationSnippetPart[@"layout"],
                       implementationSnippetPart[@"implementation_tag"][1]]])
}

function templateBinding(targetView)
{
    var template = [NSMutableDictionary dictionary]

    template[@"<CLASS_NAME>"] = [target name]

    log("Collecting iVars and layout")
    var iVars = [NSMutableArray array];
    var inits = [NSMutableArray array];
    var addSubviews = [NSMutableArray array];
    var layouts = [NSMutableArray array];

    visitLayerInGroup(target, function(layer){

      var layerName = [layer name]
      var layerClass = NSStringFromClass([layer class]);
      var mapDesc = classMapping[layerClass]

      if(mapDesc != nil)
      {
          var viewClass = mapDesc[@"viewClass"]
          var viewDesc = viewDescriptors[viewClass]

          log("Layer:" + layerClass + " name:" + layerName + " layerClass:" + viewClass + " viewDesc:" + viewDesc)

          var iVarString = iVarDeclaration(viewClass, layerName)
          [iVars addObject:"\t" + iVarString]

          var initString = initDefinition(layer, layerName, viewDesc, mapDesc);
          [inits addObject:"\t" + initString]

          var addSubviewString = addSubviewDefinition(layerName);
          [addSubviews addObject:"\t" + addSubviewString]

          var layoutString = layoutDefinition(layer, layerName)
          [layouts addObject:"\t" + layoutString]
      }
    })

    template[@"<SUBVIEW_DECLARATION>"] = renderItems(iVars)
    template[@"<SUBVIEW_INIT>"] = renderItems(inits)
    template[@"<SUBVIEW_ADD>"] = renderItems(addSubviews)
    template[@"<SUBVIEW_LAYOUT>"] = renderItems(layouts)

    return template
}

////
// Rendering
///
function iVarDeclaration(className, varName)
{
  return className + " *" + iVarName(varName) + ";"
}

function initDefinition(layer, varName, viewDesc, mapDesc)
{
    var createString = viewDesc[@"create"][@"template"]
    var initString = iVarName(varName) + " " + "=" + " " + createString + ";"

    // objectAsDictionary(layer)

    //Config
    var propertyMap = mapDesc[@"properties"]
    if(propertyMap != nil)
    {
      var configString = configStringDefinitions(layer, varName, propertyMap)
      initString = renderItems([NSArray arrayWithObjects:initString, configString, nil])
    }

    return initString
}

function configStringDefinitions(layer, varName, propertiesMap)
{
    var config = [NSMutableArray array]

    enumerateDict(propertiesMap, function(key, propertyname){

      var keyPath = [key componentsSeparatedByString:"."]

      var value = [layer valueForKeyPath:key]

      log("ValyeForKeyPath :" + key + " " + value)

      if(value == nil)
      {
        return
      }

      var configString = nil

      var valueAsDictionary = objectAsDictionary(value)
      var valueClass = NSStringFromClass([value class])

      var viewClass = classMapping[valueClass][@"viewClass"]
      var viewDesc = viewDescriptors[viewClass]
      var createTemplate = viewDesc[@"create"][@"template"]

      //Not yet working (an MO* object is missing a copyWithZone:)
      enumerateDict(viewDesc[@"create"][@"bindings"], function(binding,code){

        var valueObj = evalBindigCode(code, valueAsDictionary)
        createTemplate = [createTemplate stringByReplacingOccurrencesOfString:binding withString:valueObj]
      })

      configString = "\t" + iVarName(varName) + "." + propertyname + " = " + createTemplate + ";"

      [config addObject:configString]
    });

    return renderItems(config)
}

function addSubviewDefinition(varName)
{
    var addSubview = "self" + " " + "addSubview:" + iVarName(varName)
    return messageSendText(addSubview) + ";"
}

function layoutDefinition(layer, varName)
{
    var layout = iVarName(varName) + " " + "setFrame:" + rectToString(layer.frame())
    return messageSendText(layout) + ";"
}

function rectToString(rect)
{
   return "CGRectMake(" + Math.ceil(rect.x()) + "," + Math.ceil(rect.y()) + "," + Math.ceil(rect.width()) + ","+ Math.ceil(rect.height()) +")"
}

function messageSendText(text)
{
  return "[" + text + "]"
}

function iVarName(varName)
{
  return "_" + varName;
}

function renderItems(items)
{
  var separator = @"\n"
  return renderItemsWithSeparator(items, separator)
}

function renderItemsWithSeparator(items, separator)
{
  var renderedString = @""
  var loop = [items objectEnumerator]

  while(item = [loop nextObject])
  {
      if([item isKindOfClass:[NSArray class]])
      {
          renderedString = renderedString + [item componentsJoinedByString:separator]
      }
      else
      {
          renderedString = renderedString + item
      }

      renderedString = renderedString + separator
  }

  return renderedString
}

//Parses the layer of the selected group
//MSLayerGroup -> layer of view structs
//Where view structs contains init, addition and layout update template codes
function visitLayerInGroup(targetGroup, block)
{
   var layers = []

   var loop = [[targetGroup children] objectEnumerator];
   while(layer = [loop nextObject])
   {
      if (layer == target)
      {
         continue
      }

      block(layer)
   }

   return layers
}

//Replaces the bindings defined in dictionary in the tempate string
function templateCodeWithDictionary(template, dictionary)
{
   var loop = [[dictionary allKeys] objectEnumerator]

   var finalString = template

   while(binding = [loop nextObject])
   {
      var re = new RegExp(binding, 'g');
      finalString = finalString.replace(re, dictionary[binding]);
   }

   return finalString
}

////
//IO - Write/Read
////

// () -> {Sketch view : UIKit view} mapping
function loadObjectMap()
{
    var path = pluginPath()

    path = [path stringByAppendingString:@"view.map"]

    log("Loading map at:" + path)

    id map = loadJSON(path)

    log("" + map)

    log("Map loading [Done]")

    return map
}

// name of the class -> struct that contains the header and implementation template
function loadSnippet(snippetName)
{
  var filePath = pluginPath();
  filePath = [filePath stringByAppendingString:snippetName]
  filePath = [filePath stringByAppendingString:@".snippet"]

  log("Loading snippet: " + filePath)

  id snippet = loadJSON(filePath)

  log("Snippet loaded[Done]")

  return snippet
}

function loadJSON(filePath)
{
  var errorPointer = MOPointer.alloc().initWithValue(nil)
  var data = [NSData dataWithContentsOfFile:filePath options:0 error:errorPointer]

  if(errorPointer.value())
  {
    log("Error:" + errorPointer.value())
  }

  id json =  [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:errorPointer]

  if(errorPointer.value())
  {
    log("Error:" + errorPointer.value())
  }

  return json
}

function pluginPath()
{
  var path = MSPluginManager.pluginsURL();

  path = [path absoluteString]
  path = [path stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]
  path = [path stringByReplacingOccurrencesOfString:@"file://" withString:@""]

  return path
}

function writeTextToFile(path, text)
{
     if (typeof path !== 'string')
         return false;

     // create a NSString object from the given text
     var string = NSString.stringWithUTF8String(text);

     // use the writeToFile method of the NSString object to write the text to the given URL

     var errorPointer = MOPointer.alloc().initWithValue(nil)

     var result = [string writeToFile:path atomically:1 encoding:NSUTF8StringEncoding error:errorPointer];

     if(errorPointer.value())
     {
        log("Error:" + errorPointer.value())
     }

     return result;
}

function get_dir_from_prompt(){
    var panel = [NSOpenPanel openPanel];
    [panel setMessage:"Where do you want to place your assets?"];
    [panel setCanChooseDirectories: true];
    [panel setCanChooseFiles: false];
    [panel setCanCreateDirectories:true];
    var default_dir = [[doc fileURL] URLByDeletingLastPathComponent];
    [panel setDirectoryURL:default_dir];
    if ([panel runModal] == NSOKButton){
      var message = [panel filename];
      return message;
    }
}

function enumerateDict(dict, block)
{
  var loop = [[dict allKeys] objectEnumerator]
  while (key = loop.nextObject()) {
      var value = dict[key]

      block(key, value)
  }
}

function enumerateArray(array, block)
{
  var loop = [array objectEnumerator]
  while (item = loop.nextObject()) {
      block(item)
  }
}

function evalBindigCode(code, parameter)
{
    var errorPointer = MOPointer.alloc().initWithValue(nil)
    var parameterData = [NSJSONSerialization dataWithJSONObject:parameter options:0 error:errorPointer]

    if(errorPointer.value())
    {
      log("Error:" + errorPointer.value())
    }

    var parameterString = [[NSString alloc] initWithData:parameterData encoding:4]
    var script = [code stringByReplacingOccurrencesOfString:@"<DICT>" withString:parameterString];

    var returnValue = [webView stringByEvaluatingJavaScriptFromString:script];

    return returnValue
}

function objectAsDictionary(object)
{
    if([object isKindOfClass:[NSDictionary class]])
    {
        var serializedDictionary = serializeDictionaryUsingDateFormatKey(object)]
        return serializedDictionary
    }

    var dict = [NSMutableDictionary new]

    var properties = [[[object class] mocha] propertiesWithAncestors];

    for(var i = 0; i < properties.count(); i++)
    {
        var property = properties[i]
        var propName = [property name]

        if(isExcludedPropertyName(propName))
        {
            continue;
        }

        var getterMethod = [MOMethod methodWithTarget:object selector:propName)]

        try {

          var value = getterMethod()

          // log(propName + " - " + value + " - " + typeof value)

          if(value == nil)
          {
            continue;
          }

          if(typeof value == 'object' && ([propName rangeOfString:"class"].location == NSNotFound))
          {
             value = serializeValueUsingDateFormatKey(value)
          }

          if(typeof value != 'object' || isJSONReady(value))
          {
              dict[propName] = value
          }
        } catch (e) {

        }
    }

    log(dict)

    return dict;
}

function serializeValueUsingDateFormatKey(value)
{
      if([value isKindOfClass:[NSArray class]])
      {
          // return serializeArrayUsingDateFormatKey(value);
      }
      else if(isJSONReady(value))
      {
          return value;
      }
      else if([value isKindOfClass:[NSDictionary class]])
      {
          // return serializeDictionaryUsingDateFormatKey(value);
      }
      else if(value)
      {
          // return  objectAsDictionary(value);
      }

      return nil;
}

function isJSONReady(value)
{
    return [value isKindOfClass:[NSString class]] || [value isKindOfClass:[NSNumber class]] || (typeof value == "number");
}

function serializeDictionaryUsingDateFormatKey(dictionary)
{
    var serializableDictionary = [NSMutableDictionary new];
    var loop = [[dictionary allKeys] objectEnumerator]
    while (dictKey = loop.nextObject()) {
        var dictValue = dictionary[dictKey]

        var serializedValue = serializeValueUsingDateFormatKey(dictValue);

        if(serializedValue)
        {
            serializableDictionary[dictKey] = serializedValue;
        }
    }

    return serializableDictionary;
}

function serializeArrayUsingDateFormatKey(array)
{
    var serializableArray = [NSMutableArray new];

    var loop = [array objectEnumerator]
    while (item = loop.nextObject())
    {
        var serializableValue = serializeValueUsingDateFormatKey(item);

        if(serializableValue)
        {
            [serializableArray addObject:serializableValue];
        }
    }

    return serializableArray;
}

function isExcludedPropertyName(name)
{
  var array = [NSArray arrayWithObjects:"transformStruct",nil]
  return [array containsObject:name]
}
